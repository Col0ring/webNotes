# 王者荣耀后台

## 1.创建资源

- 创建两个目录

  - admin
  - sever

- 使用Vue直接创建admin文件夹项目`vue init webpack admin`,创建完后运行`cnpm install`将相关node_modules中的依耐安装

- 手动创建server文件夹,使用`npm init -y`初始化默认的node项目,同时修改创建server目录中创建的package.json中的scripts中的自定义字段`"sever": "nodemon index.js"`,我们将以index.js作为入口文件

  ```json
  {
    "name": "server",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
      "server": "nodemon index.js",
      "test": "echo \"Error: no test specified\" && exit 1"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "dependencies": {
      "bcrypt": "^3.0.6",
      "cors": "^2.8.5",
      "express": "^5.0.0-alpha.7",
      "http-assert": "^1.4.1",
      "inflection": "^1.12.0",
      "jsonwebtoken": "^8.5.1",
      "mongoose": "^5.6.3",
      "multer": "^1.4.1"
    }
  }
  ```

  

## 2.安装依赖

### 2.1 admin目录

**admin是管理员的后台界面,需要使用Element-ui写样式和axios进行接口请求,vue2-editor来进行富文本编辑**

```shell
cnpm i element-ui axios vue2-editor -S
```

**在main.js中引用**

```js
//src/main.js
// The Vue build version to load with the `import` command
// (runtime-only or standalone) has been set in webpack.base.conf with an alias.
import Vue from "vue";
import App from "./App";
import router from "./router";

//引入全局样式
import "./style.css";

//引入ElementUI
import ElementUI from "element-ui";
import "element-ui/lib/theme-chalk/index.css";
Vue.use(ElementUI);

//引入axios
import http from "./http";
Vue.prototype.$http = http;

//使用Vue.mixin可以将需要的属性混入到全局的Vue实例中,这样就可以在全局使用它们
//这里的混合方法是专门针对的上传文件的,在下面的物品、英雄、广告位相关都有涉及
Vue.mixin({
  computed: {
    uploadUrl() {
      return this.$http.defaults.baseURL + "/upload";
    }
  },
  methods: {
    getAuthHeaders() {
      return {
        Authorization: `Bearer ${localStorage.token || ""}`
      };
    }
  }
});

Vue.config.productionTip = false;
/* eslint-disable no-new */
new Vue({
  el: "#app",
  router,
  components: { App },
  template: "<App/>"
});
```

```css
/*/src/style.css*/
.avatar-uploader .el-upload {
  border: 1px dashed #d9d9d9;
  border-radius: 6px;
  cursor: pointer;
  position: relative;
  overflow: hidden;
}
.avatar-uploader .el-upload:hover {
  border-color: #409eff;
}
.avatar-uploader-icon {
  font-size: 28px;
  color: #8c939d;
  min-width: 5rem;
  height: 5rem;
  line-height: 5rem;
  text-align: center;
}
.avatar {
  min-width: 5rem;
  height: 5rem;
  display: block;
}

```

```js
//src/http.js
import Vue from "vue";
import router from "./router/index";//用做失败后的路由判断
import axios from "axios";

const http = axios.create({
  baseURL: "http://localhost:3000/admin/api"
});

//一个拦截器,对所有请求的接口添加请求头,后台要进行对请求头的判断
http.interceptors.request.use(
  config => {
    //可以不在前面加Bearer,但是由于接口不只有一种类型,所以遵循行业规范
    if (localStorage.token) {
      config.headers.Authorization = "Bearer " + localStorage.token;
    }
    return config;
  },
  err => {
    return Promise.reject(err);
  }
);

//一个拦截器,当后台的返回状态为400以上是进入err,200进入res
http.interceptors.response.use(
  res => {
    return res;
  },
  err => {
    ///err.presponse.data.message是后端传过来的值
    if (err.response.data.message) {
      Vue.prototype.$message({
        type: "error",
        message: err.response.data.message
      });
    }

    if (err.response.status === 401) {
      router.push("/login");
    }
    return Promise.reject(err);
  }
);

export default http;
```

**注:**`vue2-editor`是在后面的文章列表中引用的



### 2.2 server目录

**server是进行所有后台相关请求的目录,前端的所有接口请求等都会在这里面进行返回,需要使用express框架(注意一定要是下一个版本,不然登录接口那无法处理),cors解决跨域问题,mongoose操作mongodb数据库,multer用于获取上传文件数据,inflection对传入的字符串进行处理,bcrypt用密码的散列处理,jsonwebtoken是服务端为前端返回一个检验登录的token,http-assert进行验证的断言,检验某个对象是否存在,如果不存在就会返回错误状态码并且自定义返回错误信息**

```shell
cnpm i express@next cors mongoose multer bcrypt jsonwebtoken http-assert inflection -S
```

- **写入入口文件中的相关依耐**

  ```js
  //index.js
  const express = require("express");
  
  const app = express();
  
  //这里是为用户登录后设置的密钥,其实应该在环境变量里面,只是为了方便写在了代码里面
  app.set("secret", "qweewqewqsadad25315");
  
  //跨域
  app.use(require("cors")());
  //post请求
  app.use(express.json());
  
  app.use("/uploads", express.static(__dirname + "/uploads"));
  
  require("./plugins/db")(app);
  require("./routes/admin/index")(app);
  
  app.listen(3000, () => {
    console.log("running http://localhost:3000");
  });
  ```

- **连接mongodb数据库**

  **在server目录创建一个plugins目录,用来进行数据库类的操作**

  ```js
  //plugins/db.js
  module.exports = app => {
    //直接导出一个函数,在外面引入的时候就直接运行了,app是入口文件传入过来的
    const mongoose = require("mongoose");
    mongoose.connect(
      "mongodb://127.0.0.1:27017/hero-demo",//链接到数据库
      {
        useNewUrlParser: true
      },
      () => {
        console.log("数据库链接成功");
      }
    );
  };
  ```



## 3.创建路由

### 3.1 admin目录

**在admin目录中创建一个views目录,在views目录中创建对应的视图组件**

```vue
<!-- src/App.vue -->
<template>
  <div id="app">
    <router-view /><!--视图层-->
  </div>
</template>

<script>
export default {
  name: "App"
};
</script>

<style>
html,
body {
  margin: 0;
  padding: 0;
}
</style>
```

```js
//src/router/index.js
import Vue from "vue";
import Router from "vue-router";
//登录路由
import Login from "../views/Login.vue";

//主路由
import Main from "../views/Main.vue";
//分类路由
import CategoryEdit from "../views/CategoryEdit.vue";
import CategoryList from "../views/CategoryList.vue";
//物品路由
import ItemEdit from "../views/ItemEdit.vue";
import ItemList from "../views/ItemList.vue";
//英雄路由
import HeroEdit from "../views/HeroEdit.vue";
import HeroList from "../views/HeroList.vue";
//文章路由
import ArticleEdit from "../views/ArticleEdit.vue";
import ArticleList from "../views/ArticleList.vue";
//广告位路由
import AdEdit from "../views/AdEdit.vue";
import AdList from "../views/AdList.vue";
//管理员路由
import AdminUserEdit from "../views/AdminUserEdit.vue";
import AdminUserList from "../views/AdminUserList.vue";

Vue.use(Router);

const router = new Router({
  routes: [
    // 加导航守卫,可以只给一个提供公共,也可以分别给要授权的路由提供授权,这里就只给登录页加了
    {
      path: "/login",
      name: "login",
      component: Login,
      meta: { isPublic: true }
    },
    {
      path: "/",
      name: "main",
      redirect: "/categories/list",
      component: Main,
      children: [
        // 分类路由
        { path: "/categories/create", component: CategoryEdit },
        { path: "/categories/edit/:id", component: CategoryEdit, props: true }, //props为true代表将传入的pararms中带的参数id都注入带props的id里面
        { path: "/categories/list", component: CategoryList },
        //物品路由
        { path: "/items/create", component: ItemEdit },
        { path: "/items/edit/:id", component: ItemEdit, props: true }, //props为true代表将传入的pararms中带的参数id都注入带props的id里面
        { path: "/items/list", component: ItemList },
        //英雄路由
        { path: "/heroes/create", component: HeroEdit },
        { path: "/heroes/edit/:id", component: HeroEdit, props: true }, //props为true代表将传入的pararms中带的参数id都注入带props的id里面
        { path: "/heroes/list", component: HeroList },
        //文字路由
        { path: "/articles/create", component: ArticleEdit },
        { path: "/articles/edit/:id", component: ArticleEdit, props: true }, //props为true代表将传入的pararms中带的参数id都注入带props的id里面
        { path: "/articles/list", component: ArticleList },
        //广告位路由
        { path: "/ads/create", component: AdEdit },
        { path: "/ads/edit/:id", component: AdEdit, props: true }, //props为true代表将传入的pararms中带的参数id都注入带props的id里面
        { path: "/ads/list", component: AdList },
        //管理员路由
        { path: "/admin_users/create", component: AdminUserEdit },
        {
          path: "/admin_users/edit/:id",
          component: AdminUserEdit,
          props: true
        }, //props为true代表将传入的pararms中带的参数id都注入带props的id里面
        { path: "/admin_users/list", component: AdminUserList }
      ]
    },
    {
      path: "*",
      name: "404",
      redirect: "/categories/list"
    }
  ]
});

router.beforeEach((to, from, next) => {
  if (!to.meta.isPublic && !localStorage.token) {
    return next("/login");
  }
  next();
});

export default router;
```

```vue
<!-- src/views/Main.vue -->
<template>
  <el-container style="height: 100vh;">
    <el-aside width="200px" style="background-color: rgb(238, 241, 246)">
      <el-menu
        router
        unique-opened
        :default-openeds="keyPath"
        :default-active="$route.path"
        @open="handleOpen"
      >
        <el-submenu index="1">
          <template slot="title">
            <i class="el-icon-message"></i>内容管理
          </template>
          <el-menu-item-group>
            <template slot="title">物品</template>
            <el-menu-item index="/items/create">新建物品</el-menu-item>
            <el-menu-item index="/items/list">物品列表</el-menu-item>
          </el-menu-item-group>
          <el-menu-item-group>
            <template slot="title">英雄</template>
            <el-menu-item index="/heroes/create">新建英雄</el-menu-item>
            <el-menu-item index="/heroes/list">英雄列表</el-menu-item>
          </el-menu-item-group>
          <el-menu-item-group>
            <template slot="title">文章</template>
            <el-menu-item index="/articles/create">新建文章</el-menu-item>
            <el-menu-item index="/articles/list">文章列表</el-menu-item>
          </el-menu-item-group>
        </el-submenu>
        <el-submenu index="2">
          <template slot="title">
            <i class="el-icon-message"></i>运营管理
          </template>
          <el-menu-item-group>
            <template slot="title">广告位</template>
            <el-menu-item index="/ads/create">新建广告位</el-menu-item>
            <el-menu-item index="/ads/list">广告位列表</el-menu-item>
          </el-menu-item-group>
        </el-submenu>
        <el-submenu index="3">
          <template slot="title">
            <i class="el-icon-message"></i>系统设置
          </template>
          <el-menu-item-group>
            <template slot="title">分类</template>
            <el-menu-item index="/categories/create">新建分类</el-menu-item>
            <el-menu-item index="/categories/list">分类列表</el-menu-item>
          </el-menu-item-group>
          <el-menu-item-group>
            <template slot="title">管理员</template>
            <el-menu-item index="/admin_users/create">新建管理员</el-menu-item>
            <el-menu-item index="/admin_users/list">分管理员列表</el-menu-item>
          </el-menu-item-group>
        </el-submenu>
      </el-menu>
    </el-aside>

    <el-container>
      <el-main>
        <router-view></router-view>
      </el-main>
    </el-container>
  </el-container>
</template>
<style>
.el-header {
  background-color: #b3c0d1;
  color: #333;
  line-height: 60px;
}

.el-aside {
  color: #333;
}
</style>

<script>
export default {
  data() {
    return {
      keyPath: ["1"]
    };
  },
  methods: {
    handleOpen(key, keyPath) {
      this.keyPath = keyPath;
    }
  }
};
</script>
```



#### 3.1.1 分类相关

- **分类创建与修改分类**

  ```vue
  <!-- src/views/CategoryEdit.vue -->
  <!-- 创建分类 -->
  <template>
    <div>
      <h1>{{id?"编辑":"新建"}}分类</h1><!--通过是否传入id来判断是创建分类还是编辑分类-->
      <el-form label-width="120px" @submit.native.prevent="save">
        <el-form-item label="上级分类">
          <el-select v-model="model.parents">
            <el-option label="无上级分类" :value="undefined"></el-option>
            <el-option v-for="item in parents" :key="item._id" :label="item.name" :value="item._id"></el-option>
          </el-select>
        </el-form-item>
        <el-form-item label="名称">
          <el-input v-model="model.name"></el-input>
        </el-form-item>
        <el-form-item>
          <el-button type="primary" native-type="submit">保存</el-button>
          <el-button @click="$router.push('/categories/list')">取消</el-button>
        </el-form-item>
      </el-form>
    </div>
  </template>
  
  <script>
  export default {
    props: ["id"],//props的id,在传入的时候params会直接赋值给它
    data() {
      return {
        model: {//创建的分类
          parents: undefined,
          name: ""
        },
        parents: []//装上级分类的列表
      };
    },
    methods: {
      async save() {//保存分类
        this.model.name = this.model.name.trim();
        if (!this.model.name) {
          this.$message({
            type: "error",
            showClose: true,
            message: "请输入分类名称"
          });
          return;
        }
  
        let res = null;
        if (this.id) {//如果有id就会请求修改的接口
          res = await this.$http.put(`rest/categories/${this.id}`, this.model);
        } else {//如果没有id就请求创建id的接口
          res = await this.$http.post("rest/categories", this.model);
        }
        this.$router.push("/categories/list");//查找接口会跳转到list界面
        this.$message({
          type: "success",
          showClose: true,
          message: "保存成功"
        });
      },
      async fetch() {//有id的时候请求接口,编辑原分类
        const res = await this.$http.get(`rest/categories/${this.id}`);
        this.model = res.data;
      },
      async fetchParents() {//请求父级分类
        const res = await this.$http.get("rest/categories");
        this.parents = res.data;
      }
    },
    created() {
      this.fetchParents();//不论是否有无id都会请求父级分类
      this.id && this.fetch(); //有id才请求
    }
  };
  </script>
  <style>
  </style>
  ```

- **分类列表**

  ```vue
  <!-- src/views/CategoryList.vue -->
  <!-- 分类列表 -->
  <template>
    <div>
      <h1>分类列表</h1>
      <el-table :data="items">
        <el-table-column prop="_id" label="ID" width="230"></el-table-column>
        <el-table-column prop="parents.name" label="上级分类"></el-table-column>
        <el-table-column prop="name" label="分类名称"></el-table-column>
        <el-table-column fixed="right" label="操作" width="100">
          <template slot-scope="scope"><!--下面编辑按钮点击后就会跳转到编辑分类页面-->
            <!--绑定的scope.row就是表格中每一行的对象-->
              <el-button
              type="text"
              size="small"
              @click="$router.push(`/categories/edit/${scope.row._id}`)"
            >编辑</el-button>
            <el-button type="text" size="small" @click="remove(scope.row)">删除</el-button>
          </template>
        </el-table-column>
      </el-table>
    </div>
  </template>
  
  <script>
  export default {
    data() {
      return {//所有分类的数据
        items: []
      };
    },
    methods: {
      async fetch() {//请求分类列表
        const res = await this.$http.get("rest/categories");
        this.items = res.data;
      },
      async remove(row) {//移除分类
        this.$confirm(`是否确定删除分类"${row.name}"?`, "提示", {
          confirmButtonText: "确定",
          cancelButtonText: "取消",
          type: "warning"
        }).then(async () => {
          const res = await this.$http.delete(`rest/categories/${row._id}`);
          this.$message({
            type: "success",
            message: "删除成功!"
          });
          this.fetch();
        });
      }
    },
    created() {//一开始就请求
      this.fetch();
    }
  };
  </script>
  <style>
  </style>
  ```



#### 3.1.2 物品相关

- **创建分类**

  ```vue
  <!-- src/views/ItemEdit.vue -->
  <!-- 创建分类 -->
  <template>
    <div>
      <h1>{{id?"编辑":"新建"}}物品</h1>
      <el-form label-width="120px" @submit.native.prevent="save">
        <el-form-item label="名称">
          <el-input v-model="model.name"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <!-- el-upload就是elment-ui中专门用于处理上传文件的组件 -->
          <el-upload
            class="avatar-uploader"
            :action="uploadUrl"
            :headers="getAuthHeaders()"
            :show-file-list="false"
            :on-success="afterUpload"
          >
            <img v-if="model.icon" :src="model.icon" class="avatar" />
            <i v-else class="el-icon-plus avatar-uploader-icon"></i>
          </el-upload>
        </el-form-item>
        <el-form-item>
          <el-button type="primary" native-type="submit">保存</el-button>
          <el-button @click="$router.push('/items/list')">取消</el-button>
        </el-form-item>
      </el-form>
    </div>
  </template>
  
  <script>
  export default {
    props: ["id"],
    data() {
      return {
        model: {
          name: "",
          icon: ""
        }
      };
    },
    methods: {
      async save() {
        this.model.name = this.model.name.trim();
        if (!this.model.name) {
          this.$message({
            type: "error",
            showClose: true,
            message: "请输入物品名称"
          });
          return;
        }
  
        let res = null;
        if (this.id) {
          res = await this.$http.put(`rest/items/${this.id}`, this.model);
        } else {
          res = await this.$http.post("rest/items", this.model);
        }
        this.$router.push("/items/list");
        this.$message({
          type: "success",
          showClose: true,
          message: "保存成功"
        });
      },
      async fetch() {
        const res = await this.$http.get(`rest/items/${this.id}`);
        this.model = res.data;
      },
      afterUpload(res) {
        //请求完成后将请求的返回值进行赋值,该函数是在上传的时候自动调用请求
        this.model.icon = res.url;
      }
    },
    created() {
      this.id && this.fetch(); //有id才请求
    }
  };
  </script>
  <style>
  .avatar-uploader .el-upload {
    border: 1px dashed #d9d9d9;
    border-radius: 6px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
  }
  .avatar-uploader .el-upload:hover {
    border-color: #409eff;
  }
  .avatar-uploader-icon {
    font-size: 28px;
    color: #8c939d;
    width: 178px;
    height: 178px;
    line-height: 178px;
    text-align: center;
  }
  .avatar {
    width: 178px;
    height: 178px;
    display: block;
  }
  </style>
  ```

- **分类列表**

  ```vue
  <!-- src/views/ItemList.vue -->
  <!-- 分类列表 -->
  <template>
    <div>
      <h1>分类列表</h1>
      <el-table :data="items">
        <el-table-column prop="_id" label="ID" width="230"></el-table-column>
        <el-table-column prop="name" label="物品名称"></el-table-column>
        <el-table-column prop="icon" label="图标">
          <template slot-scope="scope">
            <!--自定义显示图标-->
            <img :src="scope.row.icon" style="height:3rem" alt />
          </template>
        </el-table-column>
        <el-table-column fixed="right" label="操作" width="100">
          <template slot-scope="scope">
            <el-button
              type="text"
              size="small"
              @click="$router.push(`/items/edit/${scope.row._id}`)"
            >编辑</el-button>
            <el-button type="text" size="small" @click="remove(scope.row)">删除</el-button>
          </template>
        </el-table-column>
      </el-table>
    </div>
  </template>
  
  <script>
  export default {
    data() {
      return {
        items: []
      };
    },
    methods: {
      async fetch() {
        const res = await this.$http.get("rest/items");
        this.items = res.data;
      },
      async remove(row) {
        this.$confirm(`是否确定删除物品"${row.name}"?`, "提示", {
          confirmButtonText: "确定",
          cancelButtonText: "取消",
          type: "warning"
        }).then(async () => {
          const res = await this.$http.delete(`rest/items/${row._id}`);
          this.$message({
            type: "success",
            message: "删除成功!"
          });
          this.fetch();
        });
      }
    },
    created() {
      this.fetch();
    }
  };
  </script>
  <style>
  </style>
  ```




#### 3.1.3 英雄相关

- **创建英雄**

  ```vue
  <!-- src/views/HeroEdit.vue -->
  <!-- 创建英雄 -->
  <template>
    <div>
      <h1>{{id?"编辑":"新建"}}英雄</h1>
      <el-form label-width="120px" @submit.native.prevent="save">
        <el-tabs type="border-card" value="basic">
          <el-tab-pane label="基础信息" name="basic">
            <el-form-item label="名称">
              <el-input v-model="model.name"></el-input>
            </el-form-item>
            <el-form-item label="头像">
              <!-- el-upload就是elment-ui中专门用于处理上传文件的组件 -->
              <el-upload
                class="avatar-uploader"
                :action="uploadUrl"
                :headers="getAuthHeaders()"
                :show-file-list="false"
                :on-success="afterUpload"
              >
                <img v-if="model.avater" :src="model.avater" class="avatar" />
                <i v-else class="el-icon-plus avatar-uploader-icon"></i>
              </el-upload>
            </el-form-item>
            <el-form-item label="称号">
              <el-input v-model="model.title"></el-input>
            </el-form-item>
            <el-form-item label="类型">
              <el-select v-model="model.categories" multiple>
                <!--multiple为可以多选-->
                <el-option
                  v-for="item in categories"
                  :key="item._id"
                  :label="item.name"
                  :value="item._id"
                ></el-option>
              </el-select>
            </el-form-item>
            <!-- 评分 -->
            <el-form-item label="难度">
              <!-- 多层级的对象请求可能报错,所以需要用事先定义该属性 -->
              <!-- el-rate为一个评分组合 -->
              <el-rate
                style="margin-top:0.6rem"
                :max="10"
                show-score
                v-model="model.scores.difficult"
              ></el-rate>
            </el-form-item>
            <el-form-item label="技能">
              <!-- 多层级的对象请求可能报错,所以需要用事先定义该属性 -->
              <!-- el-rate为一个评分组合 -->
              <el-rate style="margin-top:0.6rem" :max="10" show-score v-model="model.scores.skills"></el-rate>
            </el-form-item>
            <el-form-item label="攻击">
              <!-- 多层级的对象请求可能报错,所以需要用事先定义该属性 -->
              <!-- el-rate为一个评分组合 -->
              <el-rate style="margin-top:0.6rem" :max="10" show-score v-model="model.scores.attack"></el-rate>
            </el-form-item>
            <el-form-item label="生存">
              <!-- 多层级的对象请求可能报错,所以需要用事先定义该属性 -->
              <!-- el-rate为一个评分组合 -->
              <el-rate style="margin-top:0.6rem" :max="10" show-score v-model="model.scores.survive"></el-rate>
            </el-form-item>
            <!-- 出装 -->
            <el-form-item label="顺风出装">
              <el-select v-model="model.item1" multiple>
                <!--multiple为可以多选-->
                <el-option v-for="item in items" :key="item._id" :label="item.name" :value="item._id"></el-option>
              </el-select>
            </el-form-item>
            <el-form-item label="逆风出装">
              <el-select v-model="model.item2" multiple>
                <!--multiple为可以多选-->
                <el-option v-for="item in items" :key="item._id" :label="item.name" :value="item._id"></el-option>
              </el-select>
            </el-form-item>
  
            <el-form-item label="使用技巧">
              <el-input type="textarea" v-model="model.usageTips"></el-input>
            </el-form-item>
            <el-form-item label="对抗技巧">
              <el-input type="textarea" v-model="model.battleTips"></el-input>
            </el-form-item>
            <el-form-item label="团战思路">
              <el-input type="textarea" v-model="model.temTips"></el-input>
            </el-form-item>
          </el-tab-pane>
  
          <el-tab-pane label="技能" name="skills">
            <el-button @click="model.skills.push({})" size="small">
              <i class="el-icon-plus"></i>添加技能
            </el-button>
            <el-row type="flex" style="flex-wrap:wrap">
              <el-col :md="12" v-for="(item,index) in model.skills" :key="index">
                <el-form-item label="名称">
                  <el-input v-model="item.name"></el-input>
                </el-form-item>
  
                <el-form-item label="图标">
                  <!-- on-success需要改变,因为是复制到每个技能的icon属性上,并且由于是增加一个新的属性,是需要使用$set来进行设置 -->
                  <el-upload
                    class="avatar-uploader"
                    :action="uploadUrl"
                    :headers="getAuthHeaders()"
                    :show-file-list="false"
                    :on-success="res => $set(item,'icon',res.url)"
                  >
                    <img v-if="item.icon" :src="item.icon" class="avatar" />
                    <i v-else class="el-icon-plus avatar-uploader-icon"></i>
                  </el-upload>
                </el-form-item>
  
                <el-form-item label="描述">
                  <el-input type="textarea" v-model="item.description"></el-input>
                </el-form-item>
  
                <el-form-item label="小提示">
                  <el-input type="textarea" v-model="item.tips"></el-input>
                </el-form-item>
                <el-form-item>
                  <el-button size="small" type="danger" @click="removeSkill(index)">删除</el-button>
                </el-form-item>
              </el-col>
            </el-row>
          </el-tab-pane>
        </el-tabs>
  
        <el-form-item style="margin-top:1rem">
          <el-button type="primary" native-type="submit">保存</el-button>
          <el-button @click="$router.push('/heroes/list')">取消</el-button>
        </el-form-item>
      </el-form>
    </div>
  </template>
  
  <script>
  export default {
    props: ["id"],
    data() {
      return {
        //英雄的分类
        categories: [],
        //物品
        items: [],
        model: {
          name: "",
          avater: "",
          title: "",
          scores: {
            difficult: 0
          },
          usageTips: "",
          skills: []
        }
      };
    },
    methods: {
      async save() {
        this.model.name = this.model.name.trim();
        if (!this.model.name) {
          this.$message({
            type: "error",
            showClose: true,
            message: "请输入英雄名称"
          });
          return;
        }
  
        let res = null;
        if (this.id) {
          res = await this.$http.put(`rest/heroes/${this.id}`, this.model);
        } else {
          res = await this.$http.post("rest/heroes", this.model);
        }
        this.$router.push("/heroes/list");
        this.$message({
          type: "success",
          showClose: true,
          message: "保存成功"
        });
      },
      removeSkill(index) {
        this.$confirm(`是否确定删除该技能吗(如果不保存也不会删除)?`, "提示", {
          confirmButtonText: "确定",
          cancelButtonText: "取消",
          type: "warning"
        }).then(() => {
          this.model.skills.splice(index, 1);
        });
      },
      async fetch() {
        const res = await this.$http.get(`rest/heroes/${this.id}`);
        // 最好不使用直接覆盖掉原来对象的方法,而是使用对象合并的方法,避免报错
        this.model = Object.assign({}, this.model, res.data);
      },
      async fetchCategories() {
        const res = await this.$http.get(`rest/categories`);
        this.categories = res.data;
      },
      async fetchItems() {
        const res = await this.$http.get(`rest/items`);
        this.items = res.data;
      },
      afterUpload(res) {
        //请求完成后将请求的返回值进行赋值,该函数是在上传的时候自动调用请求
        this.model.avater = res.url;
      }
    },
    created() {
      this.fetchItems();
      this.fetchCategories();
      this.id && this.fetch(); //有id才请求
    }
  };
  </script>
  <style>
  .avatar-uploader .el-upload {
    border: 1px dashed #d9d9d9;
    border-radius: 6px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
  }
  .avatar-uploader .el-upload:hover {
    border-color: #409eff;
  }
  .avatar-uploader-icon {
    font-size: 28px;
    color: #8c939d;
    width: 5rem;
    height: 5rem;
    line-height: 5rem;
    text-align: center;
  }
  .avatar {
    width: 5rem;
    height: 5rem;
    display: block;
  }
  </style>
  ```

- **英雄列表**

  ```vue
  <!-- src/views/HeroList.vue -->
  <!-- 英雄列表 -->
  <template>
    <div>
      <h1>英雄列表</h1>
      <el-table :data="items">
        <el-table-column prop="_id" label="ID" width="230"></el-table-column>
        <el-table-column prop="name" label="英雄名称"></el-table-column>
        <el-table-column prop="avater" label="头像">
          <template slot-scope="scope">
            <!--自定义显示图标-->
            <img :src="scope.row.avater" style="height:3rem" alt />
          </template>
        </el-table-column>
        <el-table-column fixed="right" label="操作" width="100">
          <template slot-scope="scope">
            <el-button
              type="text"
              size="small"
              @click="$router.push(`/heroes/edit/${scope.row._id}`)"
            >编辑</el-button>
            <el-button type="text" size="small" @click="remove(scope.row)">删除</el-button>
          </template>
        </el-table-column>
      </el-table>
    </div>
  </template>
  
  <script>
  export default {
    data() {
      return {
        items: []
      };
    },
    methods: {
      async fetch() {
        const res = await this.$http.get("rest/heroes");
        this.items = res.data;
      },
      async remove(row) {
        this.$confirm(`是否确定删除英雄"${row.name}"?`, "提示", {
          confirmButtonText: "确定",
          cancelButtonText: "取消",
          type: "warning"
        }).then(async () => {
          const res = await this.$http.delete(`rest/heroes/${row._id}`);
          this.$message({
            type: "success",
            message: "删除成功!"
          });
          this.fetch();
        });
      }
    },
    created() {
      this.fetch();
    }
  };
  </script>
  <style>
  </style>
  ```




#### 3.1.4 文章相关

- **创建文章**

  ```vue
  <!-- src/views/ArticleEdit.vue -->
  <!-- 创建文章 -->
  <template>
    <div>
      <h1>{{id?"编辑":"新建"}}文章</h1>
      <el-form label-width="120px" @submit.native.prevent="save">
        <el-form-item label="所属分类">
          <el-select v-model="model.categories" multiple>
            <el-option
              v-for="item in categories"
              :key="item._id"
              :label="item.name"
              :value="item._id"
            ></el-option>
          </el-select>
        </el-form-item>
        <el-form-item label="标题">
          <el-input v-model="model.title"></el-input>
        </el-form-item>
        <el-form-item label="详情">
          <!-- 设置图片上传的时候需要自定义,不然数据量太大了 -->
          <vue-editor useCustomImageHandler @imageAdded="handleImageAdded" v-model="model.body"></vue-editor>  
        </el-form-item>
        <el-form-item>
          <el-button type="primary" native-type="submit">保存</el-button>
          <el-button @click="$router.push('/articles/list')">取消</el-button>
        </el-form-item>
      </el-form>
    </div>
  </template>
  
  <script>
  //在这里引入富文本编译器
  import { VueEditor } from "vue2-editor";
  
  export default {
    props: ["id"],
    data() {
      return {
        model: {
          categories: [],
          title: "",
          body: ""
        },
        categories: []
      };
    },
    components: {
      VueEditor
    },
    methods: {
      async handleImageAdded(file, Editor, cursorLocation, resetUploader) {
        const formData = new FormData();
        //改名为file是为了和后端对接
        formData.append("file", file);
  
        const res = await this.$http.post("upload", formData);
        Editor.insertEmbed(cursorLocation, "image", res.data.url); //这里的url也是后端传过来的
        resetUploader();
      },
      async save() {
        console.log(this.model.categories);
        this.model.title = this.model.title.trim();
        if (!this.model.title) {
          this.$message({
            type: "error",
            showClose: true,
            message: "请输入文章标题"
          });
          return;
        } else if (!this.model.categories.length) {
          this.$message({
            type: "error",
            showClose: true,
            message: "请选择文章分类"
          });
          return;
        }
  
        let res = null;
        if (this.id) {
          res = await this.$http.put(`rest/articles/${this.id}`, this.model);
        } else {
          res = await this.$http.post("rest/articles", this.model);
        }
        this.$router.push("/articles/list");
        this.$message({
          type: "success",
          showClose: true,
          message: "保存成功"
        });
      },
      async fetch() {
        const res = await this.$http.get(`rest/articles/${this.id}`);
        this.model = res.data;
      },
      async fetchCategories() {
        const res = await this.$http.get("rest/categories");
        this.categories = res.data;
      }
    },
    created() {
      this.fetchCategories();
      this.id && this.fetch(); //有id才请求
    }
  };
  </script>
  <style>
  </style>
  ```

- **文章列表**

  ```vue
  <!-- src/views/ArticleList.vue -->
  <!-- 文章列表-->
  <template>
    <div>
      <h1>文章列表</h1>
      <el-table :data="items">
        <el-table-column prop="_id" label="ID" width="300"></el-table-column>
  
        <el-table-column label="分类" width="200">
          <template slot-scope="scope">
            <span v-for="item in scope.row.categories" :key="item.id">{{ item.name}}&nbsp;</span>
          </template>
        </el-table-column>
  
        <el-table-column prop="title" label="标题"></el-table-column>
        <el-table-column fixed="right" label="操作" width="100">
          <template slot-scope="scope">
            <el-button
              type="text"
              size="small"
              @click="$router.push(`/articles/edit/${scope.row._id}`)"
            >编辑</el-button>
            <el-button type="text" size="small" @click="remove(scope.row)">删除</el-button>
          </template>
        </el-table-column>
      </el-table>
    </div>
  </template>
  
  <script>
  export default {
    data() {
      return {
        items: []
      };
    },
    methods: {
      async fetch() {
        const res = await this.$http.get("rest/articles");
        this.items = res.data;
        console.log(this.items);
      },
      async remove(row) {
        this.$confirm(`是否确定删除文章"${row.title}"?`, "提示", {
          confirmButtonText: "确定",
          cancelButtonText: "取消",
          type: "warning"
        }).then(async () => {
          const res = await this.$http.delete(`rest/articles/${row._id}`);
          this.$message({
            type: "success",
            message: "删除成功!"
          });
          this.fetch();
        });
      }
    },
    created() {
      this.fetch();
    }
  };
  </script>
  <style>
  </style>
  ```



#### 3.1.5 广告位相关

- **创建广告位**

  ```vue
  <!-- src/views/AdEdit.vue -->
  <!-- 创建广告位 -->
  <template>
    <div>
      <h1>{{id?"编辑":"新建"}}广告位</h1>
      <el-form label-width="120px" @submit.native.prevent="save">
        <el-form-item label="名称">
          <el-input v-model="model.name"></el-input>
        </el-form-item>
        <el-form-item label="广告">
          <el-button @click="model.items.push({})" size="small">
            <i class="el-icon-plus"></i>添加广告位
          </el-button>
          <el-row type="flex" style="flex-wrap:wrap">
            <el-col :md="24" v-for="(item,index) in model.items" :key="index">
              <el-form-item label="跳转链接">
                <el-input v-model="item.url"></el-input>
              </el-form-item>
  
              <el-form-item label="图片" style="margin-top:0.5rem;">
                <!-- on-success需要改变,因为是复制到每个技能的icon属性上,并且由于是增加一个新的属性,是需要使用$set来进行设置 -->
                <el-upload
                  class="avatar-uploader"
                  :action="uploadUrl"
                  :headers="getAuthHeaders()"
                  :show-file-list="false"
                  :on-success="res => $set(item,'image',res.url)"
                >
                  <img v-if="item.image" :src="item.image" class="avatar" />
                  <i v-else class="el-icon-plus avatar-uploader-icon"></i>
                </el-upload>
              </el-form-item>
  
              <el-form-item>
                <el-button size="small" type="danger" @click="removeItem(index)">删除</el-button>
              </el-form-item>
            </el-col>
          </el-row>
        </el-form-item>
        <el-form-item>
          <el-button type="primary" native-type="submit">保存</el-button>
          <el-button @click="$router.push('/ads/list')">取消</el-button>
        </el-form-item>
      </el-form>
    </div>
  </template>
  
  <script>
  export default {
    props: ["id"],
    data() {
      return {
        model: {
          name: "",
          items: []
        }
      };
    },
    methods: {
      async save() {
        this.model.name = this.model.name.trim();
        if (!this.model.name) {
          this.$message({
            type: "error",
            showClose: true,
            message: "请输入广告位名称"
          });
          return;
        }
  
        let res = null;
        if (this.id) {
          res = await this.$http.put(`rest/ads/${this.id}`, this.model);
        } else {
          res = await this.$http.post("rest/ads", this.model);
        }
        this.$router.push("/ads/list");
        this.$message({
          type: "success",
          showClose: true,
          message: "保存成功"
        });
      },
      removeItem(index) {
        this.$confirm(`是否确定删除广告吗(如果不保存也不会删除)?`, "提示", {
          confirmButtonText: "确定",
          cancelButtonText: "取消",
          type: "warning"
        }).then(() => {
          this.model.items.splice(index, 1);
        });
      },
      async fetch() {
        const res = await this.$http.get(`rest/ads/${this.id}`);
        this.model = Object.assign({}, this.model, res.data);
      }
    },
    created() {
      this.id && this.fetch(); //有id才请求
    }
  };
  </script>
  <style>
  .avatar-uploader .el-upload {
    border: 1px dashed #d9d9d9;
    border-radius: 6px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
  }
  .avatar-uploader .el-upload:hover {
    border-color: #409eff;
  }
  .avatar-uploader-icon {
    font-size: 28px;
    color: #8c939d;
    min-width: 5rem;
    height: 5rem;
    line-height: 5rem;
    text-align: center;
  }
  .avatar {
    min-width: 5rem;
    height: 5rem;
    display: block;
  }
  </style>
  ```

- **广告位列表**

  ```vue
  <!-- src/views/ArticleList.vue -->
  <!-- 广告位列表 -->
  <template>
    <div>
      <h1>广告位列表</h1>
      <el-table :data="items">
        <el-table-column prop="_id" label="ID" width="230"></el-table-column>
        <el-table-column prop="name" label="名称"></el-table-column>
        <el-table-column fixed="right" label="操作" width="100">
          <template slot-scope="scope">
            <el-button type="text" size="small" @click="$router.push(`/ads/edit/${scope.row._id}`)">编辑</el-button>
            <el-button type="text" size="small" @click="remove(scope.row)">删除</el-button>
          </template>
        </el-table-column>
      </el-table>
    </div>
  </template>
  
  <script>
  export default {
    data() {
      return {
        items: []
      };
    },
    methods: {
      async fetch() {
        const res = await this.$http.get("rest/ads");
        this.items = res.data;
      },
      async remove(row) {
        this.$confirm(`是否确定删除"${row.name}"?`, "提示", {
          confirmButtonText: "确定",
          cancelButtonText: "取消",
          type: "warning"
        }).then(async () => {
          const res = await this.$http.delete(`rest/ads/${row._id}`);
          this.$message({
            type: "success",
            message: "删除成功!"
          });
          this.fetch();
        });
      }
    },
    created() {
      this.fetch();
    }
  };
  </script>
  <style>
  </style>
  ```



#### 3.1.6 管理员相关

- **创建管理员**

  ```vue
  <!-- src/views/AdminUserEdit.vue -->
  <!-- 创建管理员 -->
  <template>
    <div>
      <h1>{{id?"编辑":"新建"}}管理员</h1>
      <el-form label-width="120px" @submit.native.prevent="save">
        <el-form-item label="用户名">
          <el-input v-model="model.username"></el-input>
        </el-form-item>
        <el-form-item label="密码">
          <el-input type="password" v-model="model.password"></el-input>
        </el-form-item>
        <el-form-item>
          <el-button type="primary" native-type="submit">保存</el-button>
          <el-button @click="$router.push('/admin_users/list')">取消</el-button>
        </el-form-item>
      </el-form>
    </div>
  </template>
  
  <script>
  export default {
    props: ["id"],
    data() {
      return {
        model: {
          username: "",
          password: ""
        }
      };
    },
    methods: {
      async save() {
        this.model.username = this.model.username.trim();
        if (!this.model.username || !this.model.username.trim()) {
          this.$message({
            type: "error",
            showClose: true,
            message: "请输入账户名"
          });
          return;
        }
  
        let res = null;
        if (this.id) {
          res = await this.$http.put(`rest/admin_users/${this.id}`, this.model);
        } else {
          res = await this.$http.post("rest/admin_users", this.model);
        }
        this.$router.push("/admin_users/list");
        this.$message({
          type: "success",
          showClose: true,
          message: "保存成功"
        });
      },
      async fetch() {
        const res = await this.$http.get(`rest/admin_users/${this.id}`);
        this.model = res.data;
      }
    },
    created() {
      this.id && this.fetch(); //有id才请求
    }
  };
  </script>
  <style>
  </style>
  ```

- **管理员列表**

  ```vue
  <!-- src/views/AdminUserList.vue -->
  <!-- 管理员列表 -->
  <template>
    <div>
      <h1>管理员列表列表</h1>
      <el-table :data="items">
        <el-table-column prop="_id" label="ID" width="230"></el-table-column>
        <el-table-column prop="username" label="用户名"></el-table-column>
        <el-table-column fixed="right" label="操作" width="100">
          <template slot-scope="scope">
            <el-button
              type="text"
              size="small"
              @click="$router.push(`/admin_users/edit/${scope.row._id}`)"
            >编辑</el-button>
            <el-button type="text" size="small" @click="remove(scope.row)">删除</el-button>
          </template>
        </el-table-column>
      </el-table>
    </div>
  </template>
  
  <script>
  export default {
    data() {
      return {
        items: []
      };
    },
    methods: {
      async fetch() {
        const res = await this.$http.get("rest/admin_users");
        this.items = res.data;
      },
      async remove(row) {
        this.$confirm(`是否确定删除管理员"${row.name}"?`, "提示", {
          confirmButtonText: "确定",
          cancelButtonText: "取消",
          type: "warning"
        }).then(async () => {
          const res = await this.$http.delete(`rest/admin_users/${row._id}`);
          this.$message({
            type: "success",
            message: "删除成功!"
          });
          this.fetch();
        });
      }
    },
    created() {
      this.fetch();
    }
  };
  </script>
  <style>
  </style>
  ```



#### 3.1.7 登录路由

```vue
<!-- src/views/Login.vue -->
<!-- 登录路由 -->
<template>
  <div class="login-container">
    <el-card header="请先登录" class="login-card">
      <el-form @submit.native.prevent="login">
        <el-form-item label="用户名">
          <el-input v-model="model.username"></el-input>
        </el-form-item>
        <el-form-item>
          <el-input type="password" v-model="model.password"></el-input>
        </el-form-item>
        <el-form-item>
          <el-button type="primary" native-type="submit">登录</el-button>
        </el-form-item>
      </el-form>
    </el-card>
  </div>
</template>

<script>
export default {
  data() {
    return {
      model: {
        username: "",
        password: ""
      }
    };
  },
  methods: {
    async login() {
      const res = await this.$http.post("login", this.model);
      //sessionStorage里面是浏览器关掉就没了
      //localStorage即使关掉也有
      localStorage.token = res.data.token;
      this.$router.push("/");
      this.$message({
        type: "success",
        message: "登录成功"
      });
    }
  }
};
</script>
<style>
.login-card {
  width: 25rem;
  margin: 5rem auto;
}
</style>
```



### 3.2 server目录

#### 3.2.1 创建Schema模型

**在server目录中创建一个models的目录,该目录专门存放需要使用的Schema模型**

- **分类模型**

  ```js
  //models/Category.js
  const mongoose = require("mongoose");//引入mongoose
  const Schema = mongoose.Schema;
  
  const schema = new Schema({//分类模型
      name: { type: String },
      parents: {//分类的父级分类,可传可不传
          type: mongoose.SchemaTypes.ObjectId,
          ref: "Category"//关联到本身的Category模型
      }
  });
  
  module.exports = mongoose.model("Category", schema);//导出该模型
  ```

- **物品模型**

  ```js
  //models/Item.js
  const mongoose = require("mongoose");
  const Schema = mongoose.Schema;
  
  const schema = new Schema({
    name: { type: String },
    icon: { type: String } //我们不会将一整张图片保存到数据库中,而是保存一个图片地址,通过数据库获取这个地址
  });
  
  module.exports = mongoose.model("Item", schema);
  ```

- **英雄模型**

  ```js
  //models/Hero.js
  const mongoose = require("mongoose");
  const Schema = mongoose.Schema;
  
  const schema = new Schema({
    name: { type: String },
    avater: { type: String }, //我们不会将一整张图片保存到数据库中,而是保存一个图片地址,通过数据库获取这个地址
    title: { type: String }, //英雄称号
    categories: [{ type: mongoose.SchemaTypes.ObjectId, ref: "Category" }], //一个英雄关联多个分类
    scores: {
      //英雄评分
      difficult: { type: Number },
      skills: { type: Number },
      attack: { type: Number },
      survive: { type: Number }
    },
    //技能,有多个技能,一个技能有图片,名字,描述,小提示等
    skills: [
      {
        icon: { type: String },
        name: { type: String },
        description: { type: String },
        tips: { type: String }
      }
    ],
    //英雄推荐装备,顺风出装和逆风出装
    item1: [{ type: mongoose.SchemaTypes.ObjectId, ref: "Item" }],
    item2: [{ type: mongoose.SchemaTypes.ObjectId, ref: "Item" }],
    //使用技巧
    usageTips: { type: String },
    //对抗技巧
    battleTips: { type: String },
    //团战技巧
    temTips: { type: String },
    //搭档及其描述
    partners: [
      {
        hero: { type: mongoose.SchemaTypes.ObjectId, ref: "Hero" },
        description: { type: String }
      }
    ]
  });
  
  module.exports = mongoose.model("Hero", schema);
  ```


- **文章模型**

  ```js
  //models/Article.js
  const mongoose = require("mongoose");
  const Schema = mongoose.Schema;
  
  const schema = new Schema({
    title: { type: String },
    categories: [
      {
        type: mongoose.SchemaTypes.ObjectId,
        ref: "Category"
      }
    ],
    body: {
      type: String
    }
  });
  
  module.exports = mongoose.model("Article", schema);
  ```

- **广告位模型**

  ```js
  //models/Ad.js
  const mongoose = require("mongoose");
  const Schema = mongoose.Schema;
  
  const schema = new Schema({
    name: { type: String },
    items: [
      {
        imgae: { type: String }, //广告位显示的图片
        url: { type: String } //点击广告位跳转的链接
      }
    ]
  });
  
  module.exports = mongoose.model("Ad", schema);
  ```

- **管理员模型**

  ```js
  //models/AdminUser.js
  const mongoose = require("mongoose");
  const Schema = mongoose.Schema;
  
  const schema = new Schema({
    username: { type: String },
    password: {
      type: String,
      select: false, //默认查的时候不带有密码
      set(val) {
        //密码的散列排布
        return require("bcrypt").hashSync(val, 10);
      }
    }
  });
  
  module.exports = mongoose.model("AdminUser", schema);
  ```

  

#### 3.2.2 admin对应路由

**在server目录中创建一个routes目录,该目录用于存放所有的后端请求,再在里面创建一个admin目录,专门用来处理管理员界面发起的接口请求**

```js
//routes/admin/index.js
//该文件中查找文件的方法是使用的一个通用接口,因为使用路由的方式基本一致,就是增删改查,所以一起写更轻松
module.exports = app => {
  const express = require("express");
  //下面两个引入都是与登录验证有关的,通用接口里面是对于接口的增删改查
  const jwt = require("jsonwebtoken");
  const AdminUser = require("../../models/AdminUser");
  const assert = require("http-assert"); //用做断言抛出异常
  const router = express.Router({
    mergeParams: true
  }); //合并URL参数,因为此参数为动态参数,通过合并才能访问到下方app.use的路径

  //添加资源
  router.post("/", async (req, res) => {
    const model = await req.Model.create(req.body);
    res.send(model);
  });
  //资源列表
  router.get("/", async (req, res) => {
    let queryOptions = {};
    if (req.Model.modelName === "Category") {
      //modelName为模型上的一个属性
      queryOptions.populate = "parents";
    } else if (req.Model.modelName == "Article") {
      queryOptions.populate = "categories";
    }
    //因为是通用接口,所以这儿的populate需要设置为选择进行的用法
    const items = await req.Model.find()
      .setOptions(queryOptions) //通过setOptions进行选择进行populate方法
      .limit(10);
    res.send(items);
  });
  //获取资源
  router.get("/:id", async (req, res) => {
    const model = await req.Model.findById(req.params.id);
    res.send(model);
  });
  //修改资源
  router.put("/:id", async (req, res) => {
    const model = await req.Model.findByIdAndUpdate(req.params.id, req.body);
    res.send(model);
  });
  //删除资源
  router.delete("/:id", async (req, res) => {
    await req.Model.findByIdAndDelete(req.params.id);
    res.send({
      success: true
    });
  });
  //登录校验中间件,要进行请求头的验证
  const authMiddleware = require("../../middleware/auth");
  //资源获取中间件,用于对传入的请求进行解析
  const resourceMiddleware = require("../../middleware/resource");

  app.use(
    //写成一个中间件的形式
    "/admin/api/rest/:resource",
    authMiddleware(),
    resourceMiddleware(),
    router
  );

  //上面是关于接口请求各种分类数据的api,下面是一些特殊的请求api
  //请求上传文件的api
  const multer = require("multer");
  //dest代表的是上传的文件要保存在什么地方,上传文件后就会自动进行保存
  const upload = multer({ dest: __dirname + "/../../uploads" });

  //upload.single()代表接收单个file文件,中间加了两个中间件
  app.post(
    "/admin/api/upload",
    authMiddleware(),
    upload.single("file"),
    async (req, res) => {
      //req.file是multer中间件为其加上的
      const file = req.file;
      //将得到的file生成一个客户端能够认识的地址返回给客户端,注意地址一定是服务端地址
      file.url = `http://localhost:3000/uploads/${file.filename}`;
      res.send(file);
    }
  );

  app.post("/admin/api/login", async (req, res) => {
    const { username, password } = req.body;
    //1.根据用户名找用户
    //因为前面默认是不取出password,这里在校验面的时候必须要取出,使用select("+passwrod")
    const user = await AdminUser.findOne({ username }).select("+password");
    //抛出异常,直接传递到最后一个错误处理函数中
    assert(user, 422, "用户不存在");

    //2.校验密码
    const isValid = require("bcrypt").compareSync(password, user.password);
    assert(isValid, 422, "密码输入错误");
    //3.返回token
    //这个可以放多个数据
    // jwt.sign({ _id: user.id, id: user.id, username: user.username });
    //因为是根据id进行查找,所以这里只放用户的id
    //app.get得到之前在index.js里面设置的密钥
    const token = jwt.sign({ id: user._id }, app.get("secret"));
    res.send({ token });
  });

  //统一的错误处理函数,想当于404页面
  app.use(async (err, req, res, next) => {
    console.log(err);
    res.status(err.statusCode || 500).send({
      message: err.message
    });
  });
};
```



#### 3.2.3 中间件

**创建一个middlewate目录,该目录专门用于存放中间件**

- **资源中间件**

  ```js
  //middleware.resource.js
  //资源请求中间件
  module.exports = options => {
    return async (req, res, next) => {
      const modelNmae = require("inflection").classify(req.params.resource);
      req.Model = require(`../models/${modelNmae}`);
      await next();
    };
  };
  ```

- **登录中间件**

  ```js
  //middleware.auth.js
  //登录验证中间件
  module.exports = options => {
    return async (req, res, next) => {
      const jwt = require("jsonwebtoken");
      const AdminUser = require("../models/AdminUser");
      const assert = require("http-assert"); //用做断言抛出异常
      //进行分割获取,因为之前前端有Bearer ,所以分割一下
      const token = String(req.headers.authorization || "")
        .split(" ")
        .pop();
      //token不能为空,否则jwt.verify无法进行
      assert(token, 401, "请先登录");
  
      //token解密出来获取到id,req.app与index.js中的app是等同的
      const { id } = jwt.verify(token, req.app.get("secret"));
      assert(id, 401, "请先登录");
  
      req.user = await AdminUser.findById(id);
      assert(req.user, 401, "请先登录");
      await next();
    };
  };
  ```

  